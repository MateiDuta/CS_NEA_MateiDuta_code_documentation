<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>simulations API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>simulations</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import vpython as vp
import numpy as np
import particles


class SolarSystem:
    DELTA_TIME = 1.0E-1
    G = 0.1  # newtons gravitational constant, 6.67e-11 to use real-world value
    NUM_PLANETS = 10  # maximum number of planets
    # skybox
    SKY = {}
    SKY[&#39;TEXTURE&#39;] = &#39;https://images.unsplash.com/&#39; \
                  &#39;photo-1475274047050-1d0c0975c63e?ixid=&#39; \
                  &#39;MnwxMjA3fDB8MHxzZWFyY2h8MXx8bm&#39; \
                  &#39;lnaHQlMjBza3l8ZW58MHx8MHx8&amp;ixlib=rb-1.2.1&amp;w=1000&amp;q=80&#39;
    SKY[&#39;SHININESS&#39;] = 1000
    SKY[&#39;RADIUS&#39;] = 200
    # scene
    SCENE = {}
    SCENE[&#39;WIDTH&#39;] = 1000
    SCENE[&#39;HEIGHT&#39;] = 400
    SCENE[&#39;RANGE&#39;] = 12
    # sun
    SUN = {}
    SUN[&#39;RADIUS&#39;] = 10
    SUN[&#39;MASS&#39;] = 10000
    # symbols for the buttons
    SYMBOLS = {}
    SYMBOLS[&#39;START&#39;] = &#39;▶️&#39;
    SYMBOLS[&#39;STOP&#39;] = &#39;⏸️&#39;
    # texts for the controls
    TEXTS = {}
    TEXTS[&#39;CAMERA&#39;] = &#39;SWITCH CAMERA FOCUS&#39;
    TEXTS[&#39;TRAILS&#39;] = &#39;TOGGLE TRAILS&#39;
    TEXTS[&#39;FORCES&#39;] = &#39;HIDE FORCES&#39;
    TEXTS[&#39;VELOCITIES&#39;] = &#39;HIDE VELOCITIES&#39;
    TEXTS[&#39;SAVE&#39;] = &#39;SAVE SYSTEM&#39;
    TEXTS[&#39;LOAD&#39;] = &#39;LOAD SYSTEM&#39;
    TEXTS[&#39;ADD&#39;] = &#39;ADD PLANET&#39;
    TEXTS[&#39;RESET&#39;] = &#39;RESET SIMULATION&#39;
    TEXTS[&#39;CLEAR&#39;] = &#39;CLEAR SYSTEM&#39;
    TEXTS[&#39;CONSTANT&#39;] = &#39;  Gravitational constant G: &#39;
    TEXTS[&#39;CONSTANTREAL&#39;] = &#39;, real value: 6.67e-11 &#39;
    TEXTS[&#39;SUN&#39;] = &#39; Mass of the sun: &#39;
    TEXTS[&#39;LIGHT&#39;] = &#39;Ambient light&#39;
    TEXTS[&#39;CHOOSE&#39;] = &#39;Choose what to edit for &#39;
    TEXTS[&#39;ERROREDIT&#39;] = &#39;first choose the variable&#39;
    TEXTS[&#39;ERRORPLANET&#39;] = &#39;Maximum number of planets in the system&#39;
    TEXTS[&#39;NOERROR&#39;] = &#39;Error: none&#39;
    TEXTS[&#39;PLANET&#39;] = &#39;Planet &#39;
    TEXTS[&#39;ONELINE&#39;] = &#39;\n&#39;
    TEXTS[&#39;TWOLINES&#39;] = &#39;\n\n&#39;
    TEXTS[&#39;SPACES&#39;] = &#39;  &#39;
    TEXTS[&#39;XPOS&#39;] = &#39;xpos &#39;
    TEXTS[&#39;YPOS&#39;] = &#39;ypos &#39;
    TEXTS[&#39;ZPOS&#39;] = &#39;zpos &#39;
    TEXTS[&#39;XVEL&#39;] = &#39;xvel &#39;
    TEXTS[&#39;YVEL&#39;] = &#39;yvel &#39;
    TEXTS[&#39;ZVEL&#39;] = &#39;zvel &#39;
    TEXTS[&#39;RAD&#39;] = &#39;rad  &#39;
    TEXTS[&#39;MASS&#39;] = &#39;mass  &#39;
    TEXTS[&#39;VAR_XPOS&#39;] = &#39;xpos&#39;
    TEXTS[&#39;VAR_YPOS&#39;] = &#39;ypos&#39;
    TEXTS[&#39;VAR_ZPOS&#39;] = &#39;zpos&#39;
    TEXTS[&#39;VAR_XVEL&#39;] = &#39;xvel&#39;
    TEXTS[&#39;VAR_YVEL&#39;] = &#39;yvel&#39;
    TEXTS[&#39;VAR_ZVEL&#39;] = &#39;zvel&#39;
    TEXTS[&#39;VAR_RAD&#39;] = &#39;rad &#39;
    TEXTS[&#39;VAR_MASS&#39;] = &#39;mass&#39;
    # file to save/load the solar system
    SYSTEM_FILE = &#39;solar_system.csv&#39;

    def __init__(self):
        self.time = 0

        self.focus = 0  # index of the followed planet
        self.running = False  # whether simulations runing or not
        self.particlelist = []  # list of bodies in the system
        self.veditlist = []
        self.valslist = []

        # assign the scene settings
        vp.scene.width = self.SCENE[&#39;WIDTH&#39;]
        vp.scene.height = self.SCENE[&#39;HEIGHT&#39;]
        vp.scene.range = self.SCENE[&#39;RANGE&#39;]
        vp.scene.lights = []

        # add the sun to scene
        self.add_sun()

        # create the graphs for the force and momentum of the first planet
        graph_force = vp.graph(scroll=True, fast=True, xmin=0, xmax=40, ymin=0, align=&#39;left&#39;,
                               width=self.SCENE[&#39;WIDTH&#39;]/2, height=self.SCENE[&#39;HEIGHT&#39;]/2,
                               foreground=vp.vector(0.5, 0.5, 0.5), background=vp.color.white,
                               xtitle=&#39;Time&#39;,
                               title=&#39;Planet 1: force_mag&#39;)
        graph_distance = vp.graph(scroll=True, fast=True, xmin=0, xmax=40, ymin=0, align=&#39;right&#39;,
                                  width=self.SCENE[&#39;WIDTH&#39;]/2, height=self.SCENE[&#39;HEIGHT&#39;]/2,
                                  foreground=vp.vector(0.5, 0.5, 0.5), background=vp.color.white,
                                  xtitle=&#39;Time&#39;,
                                  title=&#39;Planet 1: distance from the sun&#39;)
        self.plot_force = vp.gcurve(graph=graph_force, color=vp.color.blue)
        self.plot_distance = vp.gcurve(graph=graph_distance, color=vp.color.blue)

        vp.scene.append_to_caption(self.TEXTS[&#39;ONELINE&#39;])

        # button to start/stop the simulation
        self.b_startstop = vp.button(bind=self.button_startstop,
                                     text=self.SYMBOLS[&#39;START&#39;])
        vp.scene.append_to_caption(self.TEXTS[&#39;SPACES&#39;])

        # button to cycle through the planet that the camera follows
        self.b_camera = vp.button(bind=self.camera_follow,
                                  text=self.TEXTS[&#39;CAMERA&#39;])
        vp.scene.append_to_caption(self.TEXTS[&#39;SPACES&#39;])

        # button to toggle the visibility of the trails
        self.b_trails = vp.button(bind=self.button_trails,
                                  text=self.TEXTS[&#39;TRAILS&#39;])
        vp.scene.append_to_caption(self.TEXTS[&#39;SPACES&#39;])

        # button to toggle the drawing of gravitational force vectors
        self.c_force = vp.checkbox(bind=self.checkbox_force_arrows,
                                   text=self.TEXTS[&#39;FORCES&#39;])
        vp.scene.append_to_caption(&#39;  &#39;)

        # button to toggle the drawing of velocity vectors
        self.c_velocity = vp.checkbox(bind=self.checkbox_velocity_arrows,
                                      text=self.TEXTS[&#39;VELOCITIES&#39;])
        vp.scene.append_to_caption(self.TEXTS[&#39;ONELINE&#39;])

        # slider to set the level of ambient light
        vp.scene.append_to_caption(self.TEXTS[&#39;LIGHT&#39;])
        self.s_ambientlight = vp.slider(bind=self.slider_ambient_lights,
                                        min=0,
                                        max=1,
                                        left=0,
                                        length=200,
                                        value=0.5)


        # text input to set the value of G
        self.w_big_g_text = vp.wtext(text=self.TEXTS[&#39;CONSTANT&#39;] + str(self.G))
        vp.scene.append_to_caption(self.TEXTS[&#39;CONSTANTREAL&#39;])
        self.w_big_g_value = vp.winput(bind=self.winput_g,
                                       text=self.G)

        #  display the mass of the sun
        vp.scene.append_to_caption(self.TEXTS[&#39;SUN&#39;] + str(self.particlelist[0].particle_model.mass))


        vp.scene.append_to_caption(self.TEXTS[&#39;ONELINE&#39;])


        # button to reset the simulation
        self.b_reset = vp.button(bind=self.button_reset,
                                   text=self.TEXTS[&#39;RESET&#39;])

        # button to save the solar system
        self.b_save = vp.button(bind=self.button_save,
                                text=self.TEXTS[&#39;SAVE&#39;])

        # button to load the solar system
        self.b_load = vp.button(bind=self.button_load,
                                text=self.TEXTS[&#39;LOAD&#39;])

        self.t_error = vp.wtext(text=self.TEXTS[&#39;NOERROR&#39;])
        vp.scene.append_to_caption(self.TEXTS[&#39;ONELINE&#39;])


        #  button to add a planet
        self.b_add = vp.button(bind=self.button_add,
                               text=self.TEXTS[&#39;ADD&#39;])

        vp.scene.append_to_caption(self.TEXTS[&#39;ONELINE&#39;])

    def add_sun(self):
        &#34;&#34;&#34;Adds the sun to the solar system&#34;&#34;&#34;

        sun = particles.Sun(position=vp.vector(0, 0, 0),
                            radius=self.SUN[&#39;RADIUS&#39;], mass=self.SUN[&#39;MASS&#39;],
                            velocity=vp.vector(0, 0, 0),
                            color=vp.color.yellow,
                            texture=vp.textures.metal
                            )
        self.particlelist.append(sun)

    def button_startstop(self, b):
        &#34;&#34;&#34;Callback for the button to start/stop the simulation&#34;&#34;&#34;

        if len(self.particlelist) &gt; 1:
            # toggles the running state
            self.running = not self.running
            if self.running:
                self.b_startstop.text = self.SYMBOLS[&#39;STOP&#39;]
            else:
                self.b_startstop.text = self.SYMBOLS[&#39;START&#39;]

    def camera_follow(self, b):
        &#34;&#34;&#34;
            Callback to the button to set focus to the
            next particle on the list (circular)
        &#34;&#34;&#34;

        if self.focus + 1 &lt; len(self.particlelist):
            self.focus += 1
        else:
            self.focus = 0

    def update_velocity_arrow(self, particle):
        &#34;&#34;&#34;Function to update the velocity arrow&#34;&#34;&#34;

        if ((not particle.particle_model.mass == 0) and
           (not vp.mag(particle.particle_model.momentum) == 0)):
            mass = particle.particle_model.mass
            radius = particle.particle_model.radius
            momentum = particle.particle_model.momentum
            momentum_mag = vp.mag(momentum)
            velocity_log = vp.log(momentum_mag / mass, 10)
            particle.velocity_arrow.axis = (velocity_log + radius) * \
                                           (momentum / momentum_mag)
        particle.velocity_arrow.pos = particle.particle_model.pos

    def button_trails(self, b):
        &#34;&#34;&#34;Callback to the button that toggles the drawing of the trails&#34;&#34;&#34;

        for p in self.particlelist:
            p.particle_model.make_trail = not p.particle_model.make_trail
            p.particle_model.clear_trail()

    def checkbox_force_arrows(self, b):
        &#34;&#34;&#34;
            Callback to the button that toggles
            the drawing of the force vectors
        &#34;&#34;&#34;

        for p in self.particlelist:
            p.force_arrow.visible = not p.force_arrow.visible

    def checkbox_velocity_arrows(self, b):
        &#34;&#34;&#34;
            Callback to the button that toggles
            the drawing of the velocity vectors
        &#34;&#34;&#34;

        for p in self.particlelist:
            p.velocity_arrow.visible = not p.velocity_arrow.visible

    def slider_ambient_lights(self, s):
        &#34;&#34;&#34;
            Callback to the slider that sets
            the value of the ambient light
        &#34;&#34;&#34;

        vp.scene.ambient = vp.color.gray(s.value)

    def winput_g(self, w):
        &#34;&#34;&#34;
            Callback to the text input that sets
            the value of G to the user input only if integer or float
        &#34;&#34;&#34;

        if (type(w.number) == int) or (type(w.number) == float):
            self.G = w.number
            self.w_big_g_text.text = self.TEXTS[&#39;CONSTANT&#39;] + str(self.G)
            self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]
        else:
            self.t_error.text = &#39;G has to be integer or float&#39;

    def stop_simulation(self):
        &#34;&#34;&#34;Callback to the button that stops the simulation&#34;&#34;&#34;

        self.running = False
        self.b_startstop.text = self.SYMBOLS[&#39;START&#39;]

    def button_reset(self, b):
        &#34;&#34;&#34;Callback to the button to reset the simulation&#34;&#34;&#34;

        if len(self.particlelist) &gt; 1:
            for p in self.particlelist:
                p.reset_model()
                p.particle_model.clear_trail()
            self.plot_force.delete()
            self.plot_distance.delete()
            # toggles the running state
            self.running = False
            self.b_startstop.text = self.SYMBOLS[&#39;START&#39;]

    def button_add(self, b):
        &#34;&#34;&#34;
            Callback to the button that adds
            a planet up to a maximum of 9 planets
        &#34;&#34;&#34;

        if len(self.particlelist) &lt; self.NUM_PLANETS:

            self.button_reset(0)
            self.b_load.delete()

            # get the number of current, minus 1
            # because the first particle is the sun
            nplanets = len(self.particlelist) - 1
            sunradius = self.particlelist[0].radius
            sunmass = self.particlelist[0].mass
            # initial x position one more star radius away
            # from the star than previous planet
            xpos = sunradius*(nplanets + 2)
            position = vp.vector(xpos, 0, 0)
            # initial y velocity
            print(f&#34;G:{self.G}&#34;)
            zvelocity = np.sqrt((self.G * sunmass)/vp.mag(position))
            velocity = vp.vector(0, 0, zvelocity)
            # the name of the planet always has the
            # last character the planet index
            indexplanet = nplanets + 1
            radius = 1
            mass = 0.01
            self.add_planet(indexplanet, position, velocity,
                            radius, mass)
            self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]
        else:
            # deletes button if there are 9 planets
            # already in the system
            self.t_error.text = self.TEXTS[&#39;ERRORPLANET&#39;]
            b.delete()

    def add_planet(self, index, position, velocity, radius, mass):
        &#34;&#34;&#34;Function that adds a planet to the system&#34;&#34;&#34;

        # creates the planet object
        name = self.TEXTS[&#39;PLANET&#39;] + str(index)
        planet = particles.Planet(position=position,
                                  radius=radius, mass=mass,
                                  velocity=velocity,
                                  color=vp.color.white,
                                  texture=vp.textures.earth,
                                  name=name)

        self.particlelist.append(planet)
        vp.scene.append_to_caption(&#39;\n&#39; + name + &#39; &#39;)
        # sets the text for the edit values controls
        # each choice has the first 4 characters
        # the variable and the last character the planet index
        self.m_edit = vp.menu(choices=[self.TEXTS[&#39;CHOOSE&#39;] + name,
                                       self.TEXTS[&#39;XPOS&#39;] + name,
                                       self.TEXTS[&#39;YPOS&#39;] + name,
                                       self.TEXTS[&#39;ZPOS&#39;] + name,
                                       self.TEXTS[&#39;XVEL&#39;] + name,
                                       self.TEXTS[&#39;YVEL&#39;] + name,
                                       self.TEXTS[&#39;ZVEL&#39;] + name,
                                       self.TEXTS[&#39;RAD&#39;] + name,
                                       self.TEXTS[&#39;MASS&#39;] + name,
                                       ],
                              bind=self.menu_edit)
        v_edit = vp.winput(bind=self.set_value,
                           prompt=&#39;&#39;,
                           text=&#39;first choose the variable&#39;,
                           disabled=True, visible=False)
        self.veditlist.append(v_edit)
        valstext = self.particlelist[index].get_valstext()
        v_text = vp.wtext(text=valstext)
        self.valslist.append(v_text)

    def set_value(self, i):
        &#34;&#34;&#34;
            Set the value of a planet feature from the text input
        &#34;&#34;&#34;

        # only set value if integer or float
        if (type(i.number) == int) or (type(i.number) == float):
            # the variable to set is given by
            # the first characters of the prompt
            var = i.prompt[:4]
            # the index of the planet is given by
            # the last character of the prompt
            index = int(i.prompt[-1])
            # determines which value to set
            if var == self.TEXTS[&#39;VAR_XPOS&#39;]:
                pos = vp.vector(i.number,
                       self.particlelist[index].position0.y,
                       self.particlelist[index].position0.z)
                if vp.mag(pos) &gt; 0:
                    self.particlelist[index].position0.x = i.number
            elif var == self.TEXTS[&#39;VAR_YPOS&#39;]:
                pos = vp.vector(self.particlelist[index].position0.x,
                       i.number,
                       self.particlelist[index].position0.z)
                if vp.mag(pos) &gt; 0:
                    self.particlelist[index].position0.y = i.number
            elif var == self.TEXTS[&#39;VAR_ZPOS&#39;]:
                pos = vp.vector(self.particlelist[index].position0.x,
                       self.particlelist[index].position0.y,
                       i.number)
                if vp.mag(pos) &gt; 0:
                    self.particlelist[index].position0.z = i.number
            if var == self.TEXTS[&#39;VAR_XVEL&#39;]:
                self.particlelist[index].velocity0.x = i.number
            elif var == self.TEXTS[&#39;VAR_YVEL&#39;]:
                self.particlelist[index].velocity0.y = i.number
            elif var == self.TEXTS[&#39;VAR_ZVEL&#39;]:
                self.particlelist[index].velocity0.z = i.number
            elif var == self.TEXTS[&#39;VAR_RAD&#39;]:
                self.particlelist[index].radius = i.number
            elif var == self.TEXTS[&#39;VAR_MASS&#39;]:
                if i.number &gt; 0:
                    self.particlelist[index].mass = i.number
            # reset simulation
            self.button_reset(0)

            valstext = self.particlelist[index].get_valstext()
            self.valslist[index - 1].text = valstext

    def menu_edit(self, m):
        &#34;&#34;&#34;Sets the variable to edit with the text input&#34;&#34;&#34;

        # the index of the planet is given by
        # the last character of the selection
        index = int(m.selected[-1])
        if m.index &gt; 0:
            # the variable to set is given by
            # the first 4 characters of the selection
            var = m.selected[:4]
            # set the prompt for the corresponding vedit to the selection
            # the prompt[:4] then gives the variable to set
            # and prompt[-1] then gives the planet index
            self.veditlist[index - 1].prompt = m.selected
            particle = self.particlelist[index]
            if var == self.TEXTS[&#39;VAR_XPOS&#39;]:
                self.veditlist[index - 1].text = particle.position0.x
            elif var == self.TEXTS[&#39;VAR_YPOS&#39;]:
                self.veditlist[index - 1].text = particle.position0.y
            elif var == self.TEXTS[&#39;VAR_ZPOS&#39;]:
                self.veditlist[index - 1].text = particle.position0.z
            elif var == self.TEXTS[&#39;VAR_XVEL&#39;]:
                self.veditlist[index - 1].text = particle.velocity0.x
            elif var == self.TEXTS[&#39;VAR_YVEL&#39;]:
                self.veditlist[index - 1].text = particle.velocity0.y
            elif var == self.TEXTS[&#39;VAR_ZVEL&#39;]:
                self.veditlist[index - 1].text = particle.velocity0.z
            elif var == self.TEXTS[&#39;VAR_RAD&#39;]:
                self.veditlist[index - 1].text = particle.radius
            elif var == self.TEXTS[&#39;VAR_MASS&#39;]:
                self.veditlist[index - 1].text = particle.mass
            self.veditlist[index - 1].visible = True
        else:
            self.veditlist[index - 1].text = self.TEXTS[&#39;ERROREDIT&#39;]

    def button_save(self, b):
        &#34;&#34;&#34;Callback to the button to save the solar system&#34;&#34;&#34;

        vals = []
        for p in self.particlelist[1:]:
            vals.append(p.get_vals())

        try:
            np.savetxt(self.SYSTEM_FILE, vals, delimiter=&#39;,&#39;)
            self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]
        except:
            self.t_error.text = &#39;Could not save system to &#39; + \
                                self.SYSTEM_FILE

    def button_load(self, b):
        &#34;&#34;&#34;Callback to the button to load the solar system&#34;&#34;&#34;

        try:
            allvals = np.genfromtxt(self.SYSTEM_FILE, delimiter=&#39;,&#39;)
        except:
            self.t_error.text = &#39;Could not load system from &#39; + \
                                self.SYSTEM_FILE

        else:
            # only load the system once
            b.delete()
            # reset the text error if we had one
            self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]

            for index, vals in enumerate(allvals):
                position = vp.vector(vals[0], vals[1], vals[2])
                velocity = vp.vector(vals[3], vals[4], vals[5])
                radius = vals[6]
                mass = vals[7]
                self.add_planet(index + 1, position,
                                velocity, radius, mass)

    def calculate_gforce(self, p1, p2):
        &#34;&#34;&#34;
            Function that calculates the gravitational force
            exerted on p1 by p2.
            Modelled using euler cromer method.
            Based on https://www.youtube.com/watch?v=4ycpvtIio-o
            and https://www.glowscript.org/#/user/wlane/folder/Let&#39;sCodePhysics/program/Solar-System-1/edit

            Returns:
            force vector
        &#34;&#34;&#34;
        # Calculate the distance vectors between the two objects
        r_vec = p1.particle_model.pos - p2.particle_model.pos
        # Calculate magnitude of distance vector.
        r_mag = vp.mag(r_vec)
        # Calculate unit vector of distance vector.
        r_hat = r_vec / r_mag
        # Calculate force magnitude.
        p1_mass = p1.particle_model.mass
        p2_mass = p2.particle_model.mass
        force_mag = self.G * p1_mass * p2_mass / r_mag ** 2
        # Calculate force vector.
        force_vec = -force_mag * r_hat
        return force_vec

    def run(self):
        &#34;&#34;&#34;Function to run the simulation&#34;&#34;&#34;

        vp.scene.camera.axis = vp.vector(0, -1, -1)
        vp.scene.ambient = vp.color.gray(0.5)
        vp.scene.autoscale = False
        vp.scene.range = 20

        self.skybox = vp.sphere(pos=vp.vector(0, 0, 0),
                                radius=self.SKY[&#39;RADIUS&#39;],
                                shininess=self.SKY[&#39;SHININESS&#39;],
                                emissive=True,
                                texture=self.SKY[&#39;TEXTURE&#39;])
        vp.scene.camera.follow(self.skybox)

        # infinite loop
        while True:
            # if there are particles in the system set the skybox
            if len(self.particlelist) &gt; 0:
                p_model = self.particlelist[self.focus].particle_model
                self.skybox.pos = p_model.pos
            self.skybox.radius = vp.mag(vp.scene.camera.axis) * 8

            if self.running:
                if len(self.particlelist) == 0:
                    pass
                else:
                    for p1 in self.particlelist:
                        p1.totforce = vp.vector(0, 0, 0)
                        for p2 in self.particlelist:
                            if p1 != p2:
                                p1.totforce += self.calculate_gforce(p1, p2)

                        p1.particle_model.momentum += p1.totforce * self.DELTA_TIME

                        p1.particle_model.pos += (p1.particle_model.momentum * self.DELTA_TIME) / p1.particle_model.mass

                        p1.force_arrow.axis = (vp.log(vp.mag(p1.totforce), 10) + p1.particle_model.radius) * \
                                              (p1.totforce / vp.mag(p1.totforce))
                        p1.force_arrow.pos = p1.particle_model.pos

                        self.update_velocity_arrow(p1)

                    displacement = self.particlelist[1].particle_model.pos - self.particlelist[0].particle_model.pos
                    self.plot_force.plot(self.time,
                                         vp.mag(self.particlelist[1].totforce))
                    self.plot_distance.plot(self.time,
                                            vp.mag(displacement))

                    # self.plot_force.plot(self.time,
                    #                      vp.mag(self.particlelist[0].totforce))
                    # self.plot_distance.plot(self.time,
                    #                         vp.mag(self.particlelist[0].particle_model.pos))


                self.time += self.DELTA_TIME
            vp.rate(24)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="simulations.SolarSystem"><code class="flex name class">
<span>class <span class="ident">SolarSystem</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SolarSystem:
    DELTA_TIME = 1.0E-1
    G = 0.1  # newtons gravitational constant, 6.67e-11 to use real-world value
    NUM_PLANETS = 10  # maximum number of planets
    # skybox
    SKY = {}
    SKY[&#39;TEXTURE&#39;] = &#39;https://images.unsplash.com/&#39; \
                  &#39;photo-1475274047050-1d0c0975c63e?ixid=&#39; \
                  &#39;MnwxMjA3fDB8MHxzZWFyY2h8MXx8bm&#39; \
                  &#39;lnaHQlMjBza3l8ZW58MHx8MHx8&amp;ixlib=rb-1.2.1&amp;w=1000&amp;q=80&#39;
    SKY[&#39;SHININESS&#39;] = 1000
    SKY[&#39;RADIUS&#39;] = 200
    # scene
    SCENE = {}
    SCENE[&#39;WIDTH&#39;] = 1000
    SCENE[&#39;HEIGHT&#39;] = 400
    SCENE[&#39;RANGE&#39;] = 12
    # sun
    SUN = {}
    SUN[&#39;RADIUS&#39;] = 10
    SUN[&#39;MASS&#39;] = 10000
    # symbols for the buttons
    SYMBOLS = {}
    SYMBOLS[&#39;START&#39;] = &#39;▶️&#39;
    SYMBOLS[&#39;STOP&#39;] = &#39;⏸️&#39;
    # texts for the controls
    TEXTS = {}
    TEXTS[&#39;CAMERA&#39;] = &#39;SWITCH CAMERA FOCUS&#39;
    TEXTS[&#39;TRAILS&#39;] = &#39;TOGGLE TRAILS&#39;
    TEXTS[&#39;FORCES&#39;] = &#39;HIDE FORCES&#39;
    TEXTS[&#39;VELOCITIES&#39;] = &#39;HIDE VELOCITIES&#39;
    TEXTS[&#39;SAVE&#39;] = &#39;SAVE SYSTEM&#39;
    TEXTS[&#39;LOAD&#39;] = &#39;LOAD SYSTEM&#39;
    TEXTS[&#39;ADD&#39;] = &#39;ADD PLANET&#39;
    TEXTS[&#39;RESET&#39;] = &#39;RESET SIMULATION&#39;
    TEXTS[&#39;CLEAR&#39;] = &#39;CLEAR SYSTEM&#39;
    TEXTS[&#39;CONSTANT&#39;] = &#39;  Gravitational constant G: &#39;
    TEXTS[&#39;CONSTANTREAL&#39;] = &#39;, real value: 6.67e-11 &#39;
    TEXTS[&#39;SUN&#39;] = &#39; Mass of the sun: &#39;
    TEXTS[&#39;LIGHT&#39;] = &#39;Ambient light&#39;
    TEXTS[&#39;CHOOSE&#39;] = &#39;Choose what to edit for &#39;
    TEXTS[&#39;ERROREDIT&#39;] = &#39;first choose the variable&#39;
    TEXTS[&#39;ERRORPLANET&#39;] = &#39;Maximum number of planets in the system&#39;
    TEXTS[&#39;NOERROR&#39;] = &#39;Error: none&#39;
    TEXTS[&#39;PLANET&#39;] = &#39;Planet &#39;
    TEXTS[&#39;ONELINE&#39;] = &#39;\n&#39;
    TEXTS[&#39;TWOLINES&#39;] = &#39;\n\n&#39;
    TEXTS[&#39;SPACES&#39;] = &#39;  &#39;
    TEXTS[&#39;XPOS&#39;] = &#39;xpos &#39;
    TEXTS[&#39;YPOS&#39;] = &#39;ypos &#39;
    TEXTS[&#39;ZPOS&#39;] = &#39;zpos &#39;
    TEXTS[&#39;XVEL&#39;] = &#39;xvel &#39;
    TEXTS[&#39;YVEL&#39;] = &#39;yvel &#39;
    TEXTS[&#39;ZVEL&#39;] = &#39;zvel &#39;
    TEXTS[&#39;RAD&#39;] = &#39;rad  &#39;
    TEXTS[&#39;MASS&#39;] = &#39;mass  &#39;
    TEXTS[&#39;VAR_XPOS&#39;] = &#39;xpos&#39;
    TEXTS[&#39;VAR_YPOS&#39;] = &#39;ypos&#39;
    TEXTS[&#39;VAR_ZPOS&#39;] = &#39;zpos&#39;
    TEXTS[&#39;VAR_XVEL&#39;] = &#39;xvel&#39;
    TEXTS[&#39;VAR_YVEL&#39;] = &#39;yvel&#39;
    TEXTS[&#39;VAR_ZVEL&#39;] = &#39;zvel&#39;
    TEXTS[&#39;VAR_RAD&#39;] = &#39;rad &#39;
    TEXTS[&#39;VAR_MASS&#39;] = &#39;mass&#39;
    # file to save/load the solar system
    SYSTEM_FILE = &#39;solar_system.csv&#39;

    def __init__(self):
        self.time = 0

        self.focus = 0  # index of the followed planet
        self.running = False  # whether simulations runing or not
        self.particlelist = []  # list of bodies in the system
        self.veditlist = []
        self.valslist = []

        # assign the scene settings
        vp.scene.width = self.SCENE[&#39;WIDTH&#39;]
        vp.scene.height = self.SCENE[&#39;HEIGHT&#39;]
        vp.scene.range = self.SCENE[&#39;RANGE&#39;]
        vp.scene.lights = []

        # add the sun to scene
        self.add_sun()

        # create the graphs for the force and momentum of the first planet
        graph_force = vp.graph(scroll=True, fast=True, xmin=0, xmax=40, ymin=0, align=&#39;left&#39;,
                               width=self.SCENE[&#39;WIDTH&#39;]/2, height=self.SCENE[&#39;HEIGHT&#39;]/2,
                               foreground=vp.vector(0.5, 0.5, 0.5), background=vp.color.white,
                               xtitle=&#39;Time&#39;,
                               title=&#39;Planet 1: force_mag&#39;)
        graph_distance = vp.graph(scroll=True, fast=True, xmin=0, xmax=40, ymin=0, align=&#39;right&#39;,
                                  width=self.SCENE[&#39;WIDTH&#39;]/2, height=self.SCENE[&#39;HEIGHT&#39;]/2,
                                  foreground=vp.vector(0.5, 0.5, 0.5), background=vp.color.white,
                                  xtitle=&#39;Time&#39;,
                                  title=&#39;Planet 1: distance from the sun&#39;)
        self.plot_force = vp.gcurve(graph=graph_force, color=vp.color.blue)
        self.plot_distance = vp.gcurve(graph=graph_distance, color=vp.color.blue)

        vp.scene.append_to_caption(self.TEXTS[&#39;ONELINE&#39;])

        # button to start/stop the simulation
        self.b_startstop = vp.button(bind=self.button_startstop,
                                     text=self.SYMBOLS[&#39;START&#39;])
        vp.scene.append_to_caption(self.TEXTS[&#39;SPACES&#39;])

        # button to cycle through the planet that the camera follows
        self.b_camera = vp.button(bind=self.camera_follow,
                                  text=self.TEXTS[&#39;CAMERA&#39;])
        vp.scene.append_to_caption(self.TEXTS[&#39;SPACES&#39;])

        # button to toggle the visibility of the trails
        self.b_trails = vp.button(bind=self.button_trails,
                                  text=self.TEXTS[&#39;TRAILS&#39;])
        vp.scene.append_to_caption(self.TEXTS[&#39;SPACES&#39;])

        # button to toggle the drawing of gravitational force vectors
        self.c_force = vp.checkbox(bind=self.checkbox_force_arrows,
                                   text=self.TEXTS[&#39;FORCES&#39;])
        vp.scene.append_to_caption(&#39;  &#39;)

        # button to toggle the drawing of velocity vectors
        self.c_velocity = vp.checkbox(bind=self.checkbox_velocity_arrows,
                                      text=self.TEXTS[&#39;VELOCITIES&#39;])
        vp.scene.append_to_caption(self.TEXTS[&#39;ONELINE&#39;])

        # slider to set the level of ambient light
        vp.scene.append_to_caption(self.TEXTS[&#39;LIGHT&#39;])
        self.s_ambientlight = vp.slider(bind=self.slider_ambient_lights,
                                        min=0,
                                        max=1,
                                        left=0,
                                        length=200,
                                        value=0.5)


        # text input to set the value of G
        self.w_big_g_text = vp.wtext(text=self.TEXTS[&#39;CONSTANT&#39;] + str(self.G))
        vp.scene.append_to_caption(self.TEXTS[&#39;CONSTANTREAL&#39;])
        self.w_big_g_value = vp.winput(bind=self.winput_g,
                                       text=self.G)

        #  display the mass of the sun
        vp.scene.append_to_caption(self.TEXTS[&#39;SUN&#39;] + str(self.particlelist[0].particle_model.mass))


        vp.scene.append_to_caption(self.TEXTS[&#39;ONELINE&#39;])


        # button to reset the simulation
        self.b_reset = vp.button(bind=self.button_reset,
                                   text=self.TEXTS[&#39;RESET&#39;])

        # button to save the solar system
        self.b_save = vp.button(bind=self.button_save,
                                text=self.TEXTS[&#39;SAVE&#39;])

        # button to load the solar system
        self.b_load = vp.button(bind=self.button_load,
                                text=self.TEXTS[&#39;LOAD&#39;])

        self.t_error = vp.wtext(text=self.TEXTS[&#39;NOERROR&#39;])
        vp.scene.append_to_caption(self.TEXTS[&#39;ONELINE&#39;])


        #  button to add a planet
        self.b_add = vp.button(bind=self.button_add,
                               text=self.TEXTS[&#39;ADD&#39;])

        vp.scene.append_to_caption(self.TEXTS[&#39;ONELINE&#39;])

    def add_sun(self):
        &#34;&#34;&#34;Adds the sun to the solar system&#34;&#34;&#34;

        sun = particles.Sun(position=vp.vector(0, 0, 0),
                            radius=self.SUN[&#39;RADIUS&#39;], mass=self.SUN[&#39;MASS&#39;],
                            velocity=vp.vector(0, 0, 0),
                            color=vp.color.yellow,
                            texture=vp.textures.metal
                            )
        self.particlelist.append(sun)

    def button_startstop(self, b):
        &#34;&#34;&#34;Callback for the button to start/stop the simulation&#34;&#34;&#34;

        if len(self.particlelist) &gt; 1:
            # toggles the running state
            self.running = not self.running
            if self.running:
                self.b_startstop.text = self.SYMBOLS[&#39;STOP&#39;]
            else:
                self.b_startstop.text = self.SYMBOLS[&#39;START&#39;]

    def camera_follow(self, b):
        &#34;&#34;&#34;
            Callback to the button to set focus to the
            next particle on the list (circular)
        &#34;&#34;&#34;

        if self.focus + 1 &lt; len(self.particlelist):
            self.focus += 1
        else:
            self.focus = 0

    def update_velocity_arrow(self, particle):
        &#34;&#34;&#34;Function to update the velocity arrow&#34;&#34;&#34;

        if ((not particle.particle_model.mass == 0) and
           (not vp.mag(particle.particle_model.momentum) == 0)):
            mass = particle.particle_model.mass
            radius = particle.particle_model.radius
            momentum = particle.particle_model.momentum
            momentum_mag = vp.mag(momentum)
            velocity_log = vp.log(momentum_mag / mass, 10)
            particle.velocity_arrow.axis = (velocity_log + radius) * \
                                           (momentum / momentum_mag)
        particle.velocity_arrow.pos = particle.particle_model.pos

    def button_trails(self, b):
        &#34;&#34;&#34;Callback to the button that toggles the drawing of the trails&#34;&#34;&#34;

        for p in self.particlelist:
            p.particle_model.make_trail = not p.particle_model.make_trail
            p.particle_model.clear_trail()

    def checkbox_force_arrows(self, b):
        &#34;&#34;&#34;
            Callback to the button that toggles
            the drawing of the force vectors
        &#34;&#34;&#34;

        for p in self.particlelist:
            p.force_arrow.visible = not p.force_arrow.visible

    def checkbox_velocity_arrows(self, b):
        &#34;&#34;&#34;
            Callback to the button that toggles
            the drawing of the velocity vectors
        &#34;&#34;&#34;

        for p in self.particlelist:
            p.velocity_arrow.visible = not p.velocity_arrow.visible

    def slider_ambient_lights(self, s):
        &#34;&#34;&#34;
            Callback to the slider that sets
            the value of the ambient light
        &#34;&#34;&#34;

        vp.scene.ambient = vp.color.gray(s.value)

    def winput_g(self, w):
        &#34;&#34;&#34;
            Callback to the text input that sets
            the value of G to the user input only if integer or float
        &#34;&#34;&#34;

        if (type(w.number) == int) or (type(w.number) == float):
            self.G = w.number
            self.w_big_g_text.text = self.TEXTS[&#39;CONSTANT&#39;] + str(self.G)
            self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]
        else:
            self.t_error.text = &#39;G has to be integer or float&#39;

    def stop_simulation(self):
        &#34;&#34;&#34;Callback to the button that stops the simulation&#34;&#34;&#34;

        self.running = False
        self.b_startstop.text = self.SYMBOLS[&#39;START&#39;]

    def button_reset(self, b):
        &#34;&#34;&#34;Callback to the button to reset the simulation&#34;&#34;&#34;

        if len(self.particlelist) &gt; 1:
            for p in self.particlelist:
                p.reset_model()
                p.particle_model.clear_trail()
            self.plot_force.delete()
            self.plot_distance.delete()
            # toggles the running state
            self.running = False
            self.b_startstop.text = self.SYMBOLS[&#39;START&#39;]

    def button_add(self, b):
        &#34;&#34;&#34;
            Callback to the button that adds
            a planet up to a maximum of 9 planets
        &#34;&#34;&#34;

        if len(self.particlelist) &lt; self.NUM_PLANETS:

            self.button_reset(0)
            self.b_load.delete()

            # get the number of current, minus 1
            # because the first particle is the sun
            nplanets = len(self.particlelist) - 1
            sunradius = self.particlelist[0].radius
            sunmass = self.particlelist[0].mass
            # initial x position one more star radius away
            # from the star than previous planet
            xpos = sunradius*(nplanets + 2)
            position = vp.vector(xpos, 0, 0)
            # initial y velocity
            print(f&#34;G:{self.G}&#34;)
            zvelocity = np.sqrt((self.G * sunmass)/vp.mag(position))
            velocity = vp.vector(0, 0, zvelocity)
            # the name of the planet always has the
            # last character the planet index
            indexplanet = nplanets + 1
            radius = 1
            mass = 0.01
            self.add_planet(indexplanet, position, velocity,
                            radius, mass)
            self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]
        else:
            # deletes button if there are 9 planets
            # already in the system
            self.t_error.text = self.TEXTS[&#39;ERRORPLANET&#39;]
            b.delete()

    def add_planet(self, index, position, velocity, radius, mass):
        &#34;&#34;&#34;Function that adds a planet to the system&#34;&#34;&#34;

        # creates the planet object
        name = self.TEXTS[&#39;PLANET&#39;] + str(index)
        planet = particles.Planet(position=position,
                                  radius=radius, mass=mass,
                                  velocity=velocity,
                                  color=vp.color.white,
                                  texture=vp.textures.earth,
                                  name=name)

        self.particlelist.append(planet)
        vp.scene.append_to_caption(&#39;\n&#39; + name + &#39; &#39;)
        # sets the text for the edit values controls
        # each choice has the first 4 characters
        # the variable and the last character the planet index
        self.m_edit = vp.menu(choices=[self.TEXTS[&#39;CHOOSE&#39;] + name,
                                       self.TEXTS[&#39;XPOS&#39;] + name,
                                       self.TEXTS[&#39;YPOS&#39;] + name,
                                       self.TEXTS[&#39;ZPOS&#39;] + name,
                                       self.TEXTS[&#39;XVEL&#39;] + name,
                                       self.TEXTS[&#39;YVEL&#39;] + name,
                                       self.TEXTS[&#39;ZVEL&#39;] + name,
                                       self.TEXTS[&#39;RAD&#39;] + name,
                                       self.TEXTS[&#39;MASS&#39;] + name,
                                       ],
                              bind=self.menu_edit)
        v_edit = vp.winput(bind=self.set_value,
                           prompt=&#39;&#39;,
                           text=&#39;first choose the variable&#39;,
                           disabled=True, visible=False)
        self.veditlist.append(v_edit)
        valstext = self.particlelist[index].get_valstext()
        v_text = vp.wtext(text=valstext)
        self.valslist.append(v_text)

    def set_value(self, i):
        &#34;&#34;&#34;
            Set the value of a planet feature from the text input
        &#34;&#34;&#34;

        # only set value if integer or float
        if (type(i.number) == int) or (type(i.number) == float):
            # the variable to set is given by
            # the first characters of the prompt
            var = i.prompt[:4]
            # the index of the planet is given by
            # the last character of the prompt
            index = int(i.prompt[-1])
            # determines which value to set
            if var == self.TEXTS[&#39;VAR_XPOS&#39;]:
                pos = vp.vector(i.number,
                       self.particlelist[index].position0.y,
                       self.particlelist[index].position0.z)
                if vp.mag(pos) &gt; 0:
                    self.particlelist[index].position0.x = i.number
            elif var == self.TEXTS[&#39;VAR_YPOS&#39;]:
                pos = vp.vector(self.particlelist[index].position0.x,
                       i.number,
                       self.particlelist[index].position0.z)
                if vp.mag(pos) &gt; 0:
                    self.particlelist[index].position0.y = i.number
            elif var == self.TEXTS[&#39;VAR_ZPOS&#39;]:
                pos = vp.vector(self.particlelist[index].position0.x,
                       self.particlelist[index].position0.y,
                       i.number)
                if vp.mag(pos) &gt; 0:
                    self.particlelist[index].position0.z = i.number
            if var == self.TEXTS[&#39;VAR_XVEL&#39;]:
                self.particlelist[index].velocity0.x = i.number
            elif var == self.TEXTS[&#39;VAR_YVEL&#39;]:
                self.particlelist[index].velocity0.y = i.number
            elif var == self.TEXTS[&#39;VAR_ZVEL&#39;]:
                self.particlelist[index].velocity0.z = i.number
            elif var == self.TEXTS[&#39;VAR_RAD&#39;]:
                self.particlelist[index].radius = i.number
            elif var == self.TEXTS[&#39;VAR_MASS&#39;]:
                if i.number &gt; 0:
                    self.particlelist[index].mass = i.number
            # reset simulation
            self.button_reset(0)

            valstext = self.particlelist[index].get_valstext()
            self.valslist[index - 1].text = valstext

    def menu_edit(self, m):
        &#34;&#34;&#34;Sets the variable to edit with the text input&#34;&#34;&#34;

        # the index of the planet is given by
        # the last character of the selection
        index = int(m.selected[-1])
        if m.index &gt; 0:
            # the variable to set is given by
            # the first 4 characters of the selection
            var = m.selected[:4]
            # set the prompt for the corresponding vedit to the selection
            # the prompt[:4] then gives the variable to set
            # and prompt[-1] then gives the planet index
            self.veditlist[index - 1].prompt = m.selected
            particle = self.particlelist[index]
            if var == self.TEXTS[&#39;VAR_XPOS&#39;]:
                self.veditlist[index - 1].text = particle.position0.x
            elif var == self.TEXTS[&#39;VAR_YPOS&#39;]:
                self.veditlist[index - 1].text = particle.position0.y
            elif var == self.TEXTS[&#39;VAR_ZPOS&#39;]:
                self.veditlist[index - 1].text = particle.position0.z
            elif var == self.TEXTS[&#39;VAR_XVEL&#39;]:
                self.veditlist[index - 1].text = particle.velocity0.x
            elif var == self.TEXTS[&#39;VAR_YVEL&#39;]:
                self.veditlist[index - 1].text = particle.velocity0.y
            elif var == self.TEXTS[&#39;VAR_ZVEL&#39;]:
                self.veditlist[index - 1].text = particle.velocity0.z
            elif var == self.TEXTS[&#39;VAR_RAD&#39;]:
                self.veditlist[index - 1].text = particle.radius
            elif var == self.TEXTS[&#39;VAR_MASS&#39;]:
                self.veditlist[index - 1].text = particle.mass
            self.veditlist[index - 1].visible = True
        else:
            self.veditlist[index - 1].text = self.TEXTS[&#39;ERROREDIT&#39;]

    def button_save(self, b):
        &#34;&#34;&#34;Callback to the button to save the solar system&#34;&#34;&#34;

        vals = []
        for p in self.particlelist[1:]:
            vals.append(p.get_vals())

        try:
            np.savetxt(self.SYSTEM_FILE, vals, delimiter=&#39;,&#39;)
            self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]
        except:
            self.t_error.text = &#39;Could not save system to &#39; + \
                                self.SYSTEM_FILE

    def button_load(self, b):
        &#34;&#34;&#34;Callback to the button to load the solar system&#34;&#34;&#34;

        try:
            allvals = np.genfromtxt(self.SYSTEM_FILE, delimiter=&#39;,&#39;)
        except:
            self.t_error.text = &#39;Could not load system from &#39; + \
                                self.SYSTEM_FILE

        else:
            # only load the system once
            b.delete()
            # reset the text error if we had one
            self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]

            for index, vals in enumerate(allvals):
                position = vp.vector(vals[0], vals[1], vals[2])
                velocity = vp.vector(vals[3], vals[4], vals[5])
                radius = vals[6]
                mass = vals[7]
                self.add_planet(index + 1, position,
                                velocity, radius, mass)

    def calculate_gforce(self, p1, p2):
        &#34;&#34;&#34;
            Function that calculates the gravitational force
            exerted on p1 by p2.
            Modelled using euler cromer method.
            Based on https://www.youtube.com/watch?v=4ycpvtIio-o
            and https://www.glowscript.org/#/user/wlane/folder/Let&#39;sCodePhysics/program/Solar-System-1/edit

            Returns:
            force vector
        &#34;&#34;&#34;
        # Calculate the distance vectors between the two objects
        r_vec = p1.particle_model.pos - p2.particle_model.pos
        # Calculate magnitude of distance vector.
        r_mag = vp.mag(r_vec)
        # Calculate unit vector of distance vector.
        r_hat = r_vec / r_mag
        # Calculate force magnitude.
        p1_mass = p1.particle_model.mass
        p2_mass = p2.particle_model.mass
        force_mag = self.G * p1_mass * p2_mass / r_mag ** 2
        # Calculate force vector.
        force_vec = -force_mag * r_hat
        return force_vec

    def run(self):
        &#34;&#34;&#34;Function to run the simulation&#34;&#34;&#34;

        vp.scene.camera.axis = vp.vector(0, -1, -1)
        vp.scene.ambient = vp.color.gray(0.5)
        vp.scene.autoscale = False
        vp.scene.range = 20

        self.skybox = vp.sphere(pos=vp.vector(0, 0, 0),
                                radius=self.SKY[&#39;RADIUS&#39;],
                                shininess=self.SKY[&#39;SHININESS&#39;],
                                emissive=True,
                                texture=self.SKY[&#39;TEXTURE&#39;])
        vp.scene.camera.follow(self.skybox)

        # infinite loop
        while True:
            # if there are particles in the system set the skybox
            if len(self.particlelist) &gt; 0:
                p_model = self.particlelist[self.focus].particle_model
                self.skybox.pos = p_model.pos
            self.skybox.radius = vp.mag(vp.scene.camera.axis) * 8

            if self.running:
                if len(self.particlelist) == 0:
                    pass
                else:
                    for p1 in self.particlelist:
                        p1.totforce = vp.vector(0, 0, 0)
                        for p2 in self.particlelist:
                            if p1 != p2:
                                p1.totforce += self.calculate_gforce(p1, p2)

                        p1.particle_model.momentum += p1.totforce * self.DELTA_TIME

                        p1.particle_model.pos += (p1.particle_model.momentum * self.DELTA_TIME) / p1.particle_model.mass

                        p1.force_arrow.axis = (vp.log(vp.mag(p1.totforce), 10) + p1.particle_model.radius) * \
                                              (p1.totforce / vp.mag(p1.totforce))
                        p1.force_arrow.pos = p1.particle_model.pos

                        self.update_velocity_arrow(p1)

                    displacement = self.particlelist[1].particle_model.pos - self.particlelist[0].particle_model.pos
                    self.plot_force.plot(self.time,
                                         vp.mag(self.particlelist[1].totforce))
                    self.plot_distance.plot(self.time,
                                            vp.mag(displacement))

                    # self.plot_force.plot(self.time,
                    #                      vp.mag(self.particlelist[0].totforce))
                    # self.plot_distance.plot(self.time,
                    #                         vp.mag(self.particlelist[0].particle_model.pos))


                self.time += self.DELTA_TIME
            vp.rate(24)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="simulations.SolarSystem.DELTA_TIME"><code class="name">var <span class="ident">DELTA_TIME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulations.SolarSystem.G"><code class="name">var <span class="ident">G</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulations.SolarSystem.NUM_PLANETS"><code class="name">var <span class="ident">NUM_PLANETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulations.SolarSystem.SCENE"><code class="name">var <span class="ident">SCENE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulations.SolarSystem.SKY"><code class="name">var <span class="ident">SKY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulations.SolarSystem.SUN"><code class="name">var <span class="ident">SUN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulations.SolarSystem.SYMBOLS"><code class="name">var <span class="ident">SYMBOLS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulations.SolarSystem.SYSTEM_FILE"><code class="name">var <span class="ident">SYSTEM_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulations.SolarSystem.TEXTS"><code class="name">var <span class="ident">TEXTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="simulations.SolarSystem.add_planet"><code class="name flex">
<span>def <span class="ident">add_planet</span></span>(<span>self, index, position, velocity, radius, mass)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that adds a planet to the system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_planet(self, index, position, velocity, radius, mass):
    &#34;&#34;&#34;Function that adds a planet to the system&#34;&#34;&#34;

    # creates the planet object
    name = self.TEXTS[&#39;PLANET&#39;] + str(index)
    planet = particles.Planet(position=position,
                              radius=radius, mass=mass,
                              velocity=velocity,
                              color=vp.color.white,
                              texture=vp.textures.earth,
                              name=name)

    self.particlelist.append(planet)
    vp.scene.append_to_caption(&#39;\n&#39; + name + &#39; &#39;)
    # sets the text for the edit values controls
    # each choice has the first 4 characters
    # the variable and the last character the planet index
    self.m_edit = vp.menu(choices=[self.TEXTS[&#39;CHOOSE&#39;] + name,
                                   self.TEXTS[&#39;XPOS&#39;] + name,
                                   self.TEXTS[&#39;YPOS&#39;] + name,
                                   self.TEXTS[&#39;ZPOS&#39;] + name,
                                   self.TEXTS[&#39;XVEL&#39;] + name,
                                   self.TEXTS[&#39;YVEL&#39;] + name,
                                   self.TEXTS[&#39;ZVEL&#39;] + name,
                                   self.TEXTS[&#39;RAD&#39;] + name,
                                   self.TEXTS[&#39;MASS&#39;] + name,
                                   ],
                          bind=self.menu_edit)
    v_edit = vp.winput(bind=self.set_value,
                       prompt=&#39;&#39;,
                       text=&#39;first choose the variable&#39;,
                       disabled=True, visible=False)
    self.veditlist.append(v_edit)
    valstext = self.particlelist[index].get_valstext()
    v_text = vp.wtext(text=valstext)
    self.valslist.append(v_text)</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.add_sun"><code class="name flex">
<span>def <span class="ident">add_sun</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the sun to the solar system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sun(self):
    &#34;&#34;&#34;Adds the sun to the solar system&#34;&#34;&#34;

    sun = particles.Sun(position=vp.vector(0, 0, 0),
                        radius=self.SUN[&#39;RADIUS&#39;], mass=self.SUN[&#39;MASS&#39;],
                        velocity=vp.vector(0, 0, 0),
                        color=vp.color.yellow,
                        texture=vp.textures.metal
                        )
    self.particlelist.append(sun)</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.button_add"><code class="name flex">
<span>def <span class="ident">button_add</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the button that adds
a planet up to a maximum of 9 planets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def button_add(self, b):
    &#34;&#34;&#34;
        Callback to the button that adds
        a planet up to a maximum of 9 planets
    &#34;&#34;&#34;

    if len(self.particlelist) &lt; self.NUM_PLANETS:

        self.button_reset(0)
        self.b_load.delete()

        # get the number of current, minus 1
        # because the first particle is the sun
        nplanets = len(self.particlelist) - 1
        sunradius = self.particlelist[0].radius
        sunmass = self.particlelist[0].mass
        # initial x position one more star radius away
        # from the star than previous planet
        xpos = sunradius*(nplanets + 2)
        position = vp.vector(xpos, 0, 0)
        # initial y velocity
        print(f&#34;G:{self.G}&#34;)
        zvelocity = np.sqrt((self.G * sunmass)/vp.mag(position))
        velocity = vp.vector(0, 0, zvelocity)
        # the name of the planet always has the
        # last character the planet index
        indexplanet = nplanets + 1
        radius = 1
        mass = 0.01
        self.add_planet(indexplanet, position, velocity,
                        radius, mass)
        self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]
    else:
        # deletes button if there are 9 planets
        # already in the system
        self.t_error.text = self.TEXTS[&#39;ERRORPLANET&#39;]
        b.delete()</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.button_load"><code class="name flex">
<span>def <span class="ident">button_load</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the button to load the solar system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def button_load(self, b):
    &#34;&#34;&#34;Callback to the button to load the solar system&#34;&#34;&#34;

    try:
        allvals = np.genfromtxt(self.SYSTEM_FILE, delimiter=&#39;,&#39;)
    except:
        self.t_error.text = &#39;Could not load system from &#39; + \
                            self.SYSTEM_FILE

    else:
        # only load the system once
        b.delete()
        # reset the text error if we had one
        self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]

        for index, vals in enumerate(allvals):
            position = vp.vector(vals[0], vals[1], vals[2])
            velocity = vp.vector(vals[3], vals[4], vals[5])
            radius = vals[6]
            mass = vals[7]
            self.add_planet(index + 1, position,
                            velocity, radius, mass)</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.button_reset"><code class="name flex">
<span>def <span class="ident">button_reset</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the button to reset the simulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def button_reset(self, b):
    &#34;&#34;&#34;Callback to the button to reset the simulation&#34;&#34;&#34;

    if len(self.particlelist) &gt; 1:
        for p in self.particlelist:
            p.reset_model()
            p.particle_model.clear_trail()
        self.plot_force.delete()
        self.plot_distance.delete()
        # toggles the running state
        self.running = False
        self.b_startstop.text = self.SYMBOLS[&#39;START&#39;]</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.button_save"><code class="name flex">
<span>def <span class="ident">button_save</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the button to save the solar system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def button_save(self, b):
    &#34;&#34;&#34;Callback to the button to save the solar system&#34;&#34;&#34;

    vals = []
    for p in self.particlelist[1:]:
        vals.append(p.get_vals())

    try:
        np.savetxt(self.SYSTEM_FILE, vals, delimiter=&#39;,&#39;)
        self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]
    except:
        self.t_error.text = &#39;Could not save system to &#39; + \
                            self.SYSTEM_FILE</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.button_startstop"><code class="name flex">
<span>def <span class="ident">button_startstop</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for the button to start/stop the simulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def button_startstop(self, b):
    &#34;&#34;&#34;Callback for the button to start/stop the simulation&#34;&#34;&#34;

    if len(self.particlelist) &gt; 1:
        # toggles the running state
        self.running = not self.running
        if self.running:
            self.b_startstop.text = self.SYMBOLS[&#39;STOP&#39;]
        else:
            self.b_startstop.text = self.SYMBOLS[&#39;START&#39;]</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.button_trails"><code class="name flex">
<span>def <span class="ident">button_trails</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the button that toggles the drawing of the trails</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def button_trails(self, b):
    &#34;&#34;&#34;Callback to the button that toggles the drawing of the trails&#34;&#34;&#34;

    for p in self.particlelist:
        p.particle_model.make_trail = not p.particle_model.make_trail
        p.particle_model.clear_trail()</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.calculate_gforce"><code class="name flex">
<span>def <span class="ident">calculate_gforce</span></span>(<span>self, p1, p2)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that calculates the gravitational force
exerted on p1 by p2.
Modelled using euler cromer method.
Based on <a href="https://www.youtube.com/watch?v=4ycpvtIio-o">https://www.youtube.com/watch?v=4ycpvtIio-o</a>
and <a href="https://www.glowscript.org/#/user/wlane/folder/Let'sCodePhysics/program/Solar-System-1/edit">https://www.glowscript.org/#/user/wlane/folder/Let'sCodePhysics/program/Solar-System-1/edit</a></p>
<p>Returns:
force vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_gforce(self, p1, p2):
    &#34;&#34;&#34;
        Function that calculates the gravitational force
        exerted on p1 by p2.
        Modelled using euler cromer method.
        Based on https://www.youtube.com/watch?v=4ycpvtIio-o
        and https://www.glowscript.org/#/user/wlane/folder/Let&#39;sCodePhysics/program/Solar-System-1/edit

        Returns:
        force vector
    &#34;&#34;&#34;
    # Calculate the distance vectors between the two objects
    r_vec = p1.particle_model.pos - p2.particle_model.pos
    # Calculate magnitude of distance vector.
    r_mag = vp.mag(r_vec)
    # Calculate unit vector of distance vector.
    r_hat = r_vec / r_mag
    # Calculate force magnitude.
    p1_mass = p1.particle_model.mass
    p2_mass = p2.particle_model.mass
    force_mag = self.G * p1_mass * p2_mass / r_mag ** 2
    # Calculate force vector.
    force_vec = -force_mag * r_hat
    return force_vec</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.camera_follow"><code class="name flex">
<span>def <span class="ident">camera_follow</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the button to set focus to the
next particle on the list (circular)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def camera_follow(self, b):
    &#34;&#34;&#34;
        Callback to the button to set focus to the
        next particle on the list (circular)
    &#34;&#34;&#34;

    if self.focus + 1 &lt; len(self.particlelist):
        self.focus += 1
    else:
        self.focus = 0</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.checkbox_force_arrows"><code class="name flex">
<span>def <span class="ident">checkbox_force_arrows</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the button that toggles
the drawing of the force vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkbox_force_arrows(self, b):
    &#34;&#34;&#34;
        Callback to the button that toggles
        the drawing of the force vectors
    &#34;&#34;&#34;

    for p in self.particlelist:
        p.force_arrow.visible = not p.force_arrow.visible</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.checkbox_velocity_arrows"><code class="name flex">
<span>def <span class="ident">checkbox_velocity_arrows</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the button that toggles
the drawing of the velocity vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkbox_velocity_arrows(self, b):
    &#34;&#34;&#34;
        Callback to the button that toggles
        the drawing of the velocity vectors
    &#34;&#34;&#34;

    for p in self.particlelist:
        p.velocity_arrow.visible = not p.velocity_arrow.visible</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.menu_edit"><code class="name flex">
<span>def <span class="ident">menu_edit</span></span>(<span>self, m)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the variable to edit with the text input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def menu_edit(self, m):
    &#34;&#34;&#34;Sets the variable to edit with the text input&#34;&#34;&#34;

    # the index of the planet is given by
    # the last character of the selection
    index = int(m.selected[-1])
    if m.index &gt; 0:
        # the variable to set is given by
        # the first 4 characters of the selection
        var = m.selected[:4]
        # set the prompt for the corresponding vedit to the selection
        # the prompt[:4] then gives the variable to set
        # and prompt[-1] then gives the planet index
        self.veditlist[index - 1].prompt = m.selected
        particle = self.particlelist[index]
        if var == self.TEXTS[&#39;VAR_XPOS&#39;]:
            self.veditlist[index - 1].text = particle.position0.x
        elif var == self.TEXTS[&#39;VAR_YPOS&#39;]:
            self.veditlist[index - 1].text = particle.position0.y
        elif var == self.TEXTS[&#39;VAR_ZPOS&#39;]:
            self.veditlist[index - 1].text = particle.position0.z
        elif var == self.TEXTS[&#39;VAR_XVEL&#39;]:
            self.veditlist[index - 1].text = particle.velocity0.x
        elif var == self.TEXTS[&#39;VAR_YVEL&#39;]:
            self.veditlist[index - 1].text = particle.velocity0.y
        elif var == self.TEXTS[&#39;VAR_ZVEL&#39;]:
            self.veditlist[index - 1].text = particle.velocity0.z
        elif var == self.TEXTS[&#39;VAR_RAD&#39;]:
            self.veditlist[index - 1].text = particle.radius
        elif var == self.TEXTS[&#39;VAR_MASS&#39;]:
            self.veditlist[index - 1].text = particle.mass
        self.veditlist[index - 1].visible = True
    else:
        self.veditlist[index - 1].text = self.TEXTS[&#39;ERROREDIT&#39;]</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to run the simulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;Function to run the simulation&#34;&#34;&#34;

    vp.scene.camera.axis = vp.vector(0, -1, -1)
    vp.scene.ambient = vp.color.gray(0.5)
    vp.scene.autoscale = False
    vp.scene.range = 20

    self.skybox = vp.sphere(pos=vp.vector(0, 0, 0),
                            radius=self.SKY[&#39;RADIUS&#39;],
                            shininess=self.SKY[&#39;SHININESS&#39;],
                            emissive=True,
                            texture=self.SKY[&#39;TEXTURE&#39;])
    vp.scene.camera.follow(self.skybox)

    # infinite loop
    while True:
        # if there are particles in the system set the skybox
        if len(self.particlelist) &gt; 0:
            p_model = self.particlelist[self.focus].particle_model
            self.skybox.pos = p_model.pos
        self.skybox.radius = vp.mag(vp.scene.camera.axis) * 8

        if self.running:
            if len(self.particlelist) == 0:
                pass
            else:
                for p1 in self.particlelist:
                    p1.totforce = vp.vector(0, 0, 0)
                    for p2 in self.particlelist:
                        if p1 != p2:
                            p1.totforce += self.calculate_gforce(p1, p2)

                    p1.particle_model.momentum += p1.totforce * self.DELTA_TIME

                    p1.particle_model.pos += (p1.particle_model.momentum * self.DELTA_TIME) / p1.particle_model.mass

                    p1.force_arrow.axis = (vp.log(vp.mag(p1.totforce), 10) + p1.particle_model.radius) * \
                                          (p1.totforce / vp.mag(p1.totforce))
                    p1.force_arrow.pos = p1.particle_model.pos

                    self.update_velocity_arrow(p1)

                displacement = self.particlelist[1].particle_model.pos - self.particlelist[0].particle_model.pos
                self.plot_force.plot(self.time,
                                     vp.mag(self.particlelist[1].totforce))
                self.plot_distance.plot(self.time,
                                        vp.mag(displacement))

                # self.plot_force.plot(self.time,
                #                      vp.mag(self.particlelist[0].totforce))
                # self.plot_distance.plot(self.time,
                #                         vp.mag(self.particlelist[0].particle_model.pos))


            self.time += self.DELTA_TIME
        vp.rate(24)</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.set_value"><code class="name flex">
<span>def <span class="ident">set_value</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the value of a planet feature from the text input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value(self, i):
    &#34;&#34;&#34;
        Set the value of a planet feature from the text input
    &#34;&#34;&#34;

    # only set value if integer or float
    if (type(i.number) == int) or (type(i.number) == float):
        # the variable to set is given by
        # the first characters of the prompt
        var = i.prompt[:4]
        # the index of the planet is given by
        # the last character of the prompt
        index = int(i.prompt[-1])
        # determines which value to set
        if var == self.TEXTS[&#39;VAR_XPOS&#39;]:
            pos = vp.vector(i.number,
                   self.particlelist[index].position0.y,
                   self.particlelist[index].position0.z)
            if vp.mag(pos) &gt; 0:
                self.particlelist[index].position0.x = i.number
        elif var == self.TEXTS[&#39;VAR_YPOS&#39;]:
            pos = vp.vector(self.particlelist[index].position0.x,
                   i.number,
                   self.particlelist[index].position0.z)
            if vp.mag(pos) &gt; 0:
                self.particlelist[index].position0.y = i.number
        elif var == self.TEXTS[&#39;VAR_ZPOS&#39;]:
            pos = vp.vector(self.particlelist[index].position0.x,
                   self.particlelist[index].position0.y,
                   i.number)
            if vp.mag(pos) &gt; 0:
                self.particlelist[index].position0.z = i.number
        if var == self.TEXTS[&#39;VAR_XVEL&#39;]:
            self.particlelist[index].velocity0.x = i.number
        elif var == self.TEXTS[&#39;VAR_YVEL&#39;]:
            self.particlelist[index].velocity0.y = i.number
        elif var == self.TEXTS[&#39;VAR_ZVEL&#39;]:
            self.particlelist[index].velocity0.z = i.number
        elif var == self.TEXTS[&#39;VAR_RAD&#39;]:
            self.particlelist[index].radius = i.number
        elif var == self.TEXTS[&#39;VAR_MASS&#39;]:
            if i.number &gt; 0:
                self.particlelist[index].mass = i.number
        # reset simulation
        self.button_reset(0)

        valstext = self.particlelist[index].get_valstext()
        self.valslist[index - 1].text = valstext</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.slider_ambient_lights"><code class="name flex">
<span>def <span class="ident">slider_ambient_lights</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the slider that sets
the value of the ambient light</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slider_ambient_lights(self, s):
    &#34;&#34;&#34;
        Callback to the slider that sets
        the value of the ambient light
    &#34;&#34;&#34;

    vp.scene.ambient = vp.color.gray(s.value)</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.stop_simulation"><code class="name flex">
<span>def <span class="ident">stop_simulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the button that stops the simulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_simulation(self):
    &#34;&#34;&#34;Callback to the button that stops the simulation&#34;&#34;&#34;

    self.running = False
    self.b_startstop.text = self.SYMBOLS[&#39;START&#39;]</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.update_velocity_arrow"><code class="name flex">
<span>def <span class="ident">update_velocity_arrow</span></span>(<span>self, particle)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to update the velocity arrow</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_velocity_arrow(self, particle):
    &#34;&#34;&#34;Function to update the velocity arrow&#34;&#34;&#34;

    if ((not particle.particle_model.mass == 0) and
       (not vp.mag(particle.particle_model.momentum) == 0)):
        mass = particle.particle_model.mass
        radius = particle.particle_model.radius
        momentum = particle.particle_model.momentum
        momentum_mag = vp.mag(momentum)
        velocity_log = vp.log(momentum_mag / mass, 10)
        particle.velocity_arrow.axis = (velocity_log + radius) * \
                                       (momentum / momentum_mag)
    particle.velocity_arrow.pos = particle.particle_model.pos</code></pre>
</details>
</dd>
<dt id="simulations.SolarSystem.winput_g"><code class="name flex">
<span>def <span class="ident">winput_g</span></span>(<span>self, w)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback to the text input that sets
the value of G to the user input only if integer or float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def winput_g(self, w):
    &#34;&#34;&#34;
        Callback to the text input that sets
        the value of G to the user input only if integer or float
    &#34;&#34;&#34;

    if (type(w.number) == int) or (type(w.number) == float):
        self.G = w.number
        self.w_big_g_text.text = self.TEXTS[&#39;CONSTANT&#39;] + str(self.G)
        self.t_error.text = self.TEXTS[&#39;NOERROR&#39;]
    else:
        self.t_error.text = &#39;G has to be integer or float&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="simulations.SolarSystem" href="#simulations.SolarSystem">SolarSystem</a></code></h4>
<ul class="">
<li><code><a title="simulations.SolarSystem.DELTA_TIME" href="#simulations.SolarSystem.DELTA_TIME">DELTA_TIME</a></code></li>
<li><code><a title="simulations.SolarSystem.G" href="#simulations.SolarSystem.G">G</a></code></li>
<li><code><a title="simulations.SolarSystem.NUM_PLANETS" href="#simulations.SolarSystem.NUM_PLANETS">NUM_PLANETS</a></code></li>
<li><code><a title="simulations.SolarSystem.SCENE" href="#simulations.SolarSystem.SCENE">SCENE</a></code></li>
<li><code><a title="simulations.SolarSystem.SKY" href="#simulations.SolarSystem.SKY">SKY</a></code></li>
<li><code><a title="simulations.SolarSystem.SUN" href="#simulations.SolarSystem.SUN">SUN</a></code></li>
<li><code><a title="simulations.SolarSystem.SYMBOLS" href="#simulations.SolarSystem.SYMBOLS">SYMBOLS</a></code></li>
<li><code><a title="simulations.SolarSystem.SYSTEM_FILE" href="#simulations.SolarSystem.SYSTEM_FILE">SYSTEM_FILE</a></code></li>
<li><code><a title="simulations.SolarSystem.TEXTS" href="#simulations.SolarSystem.TEXTS">TEXTS</a></code></li>
<li><code><a title="simulations.SolarSystem.add_planet" href="#simulations.SolarSystem.add_planet">add_planet</a></code></li>
<li><code><a title="simulations.SolarSystem.add_sun" href="#simulations.SolarSystem.add_sun">add_sun</a></code></li>
<li><code><a title="simulations.SolarSystem.button_add" href="#simulations.SolarSystem.button_add">button_add</a></code></li>
<li><code><a title="simulations.SolarSystem.button_load" href="#simulations.SolarSystem.button_load">button_load</a></code></li>
<li><code><a title="simulations.SolarSystem.button_reset" href="#simulations.SolarSystem.button_reset">button_reset</a></code></li>
<li><code><a title="simulations.SolarSystem.button_save" href="#simulations.SolarSystem.button_save">button_save</a></code></li>
<li><code><a title="simulations.SolarSystem.button_startstop" href="#simulations.SolarSystem.button_startstop">button_startstop</a></code></li>
<li><code><a title="simulations.SolarSystem.button_trails" href="#simulations.SolarSystem.button_trails">button_trails</a></code></li>
<li><code><a title="simulations.SolarSystem.calculate_gforce" href="#simulations.SolarSystem.calculate_gforce">calculate_gforce</a></code></li>
<li><code><a title="simulations.SolarSystem.camera_follow" href="#simulations.SolarSystem.camera_follow">camera_follow</a></code></li>
<li><code><a title="simulations.SolarSystem.checkbox_force_arrows" href="#simulations.SolarSystem.checkbox_force_arrows">checkbox_force_arrows</a></code></li>
<li><code><a title="simulations.SolarSystem.checkbox_velocity_arrows" href="#simulations.SolarSystem.checkbox_velocity_arrows">checkbox_velocity_arrows</a></code></li>
<li><code><a title="simulations.SolarSystem.menu_edit" href="#simulations.SolarSystem.menu_edit">menu_edit</a></code></li>
<li><code><a title="simulations.SolarSystem.run" href="#simulations.SolarSystem.run">run</a></code></li>
<li><code><a title="simulations.SolarSystem.set_value" href="#simulations.SolarSystem.set_value">set_value</a></code></li>
<li><code><a title="simulations.SolarSystem.slider_ambient_lights" href="#simulations.SolarSystem.slider_ambient_lights">slider_ambient_lights</a></code></li>
<li><code><a title="simulations.SolarSystem.stop_simulation" href="#simulations.SolarSystem.stop_simulation">stop_simulation</a></code></li>
<li><code><a title="simulations.SolarSystem.update_velocity_arrow" href="#simulations.SolarSystem.update_velocity_arrow">update_velocity_arrow</a></code></li>
<li><code><a title="simulations.SolarSystem.winput_g" href="#simulations.SolarSystem.winput_g">winput_g</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>